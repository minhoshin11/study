//reduce :배열을 돌면서 원하는 작업을 한 후 최종값을 반환
//인수로 함수를 받음
//(누적계산값, 현재값, +초기값 ) => {return 계산값}

//인수 : 변수에 들어가는 놈

let 배열 = [1,2,3,4,5];

const 결과 = 배열.reduce((누적값,현재값) => 누적값 + 현재값);
console.log(결과);

const 삼 = 배열.reduce((누적값,현재값) => 누적값 + 현재값, 3);
console.log(삼);
//저 뒤에 3을 넣어주면 누적값이 3인 상태로 시작임
//물론 암것도 없으면 0으로 시작함.

const 곱하기 = 배열.reduce((누적값,현재값)=> 누적값 * 현재값 , 2);
console.log(곱하기);
//(초기값)*배열 = 2 * 1*2*3*4*5


const 나머지 = 배열.reduce((누적값,현재값)=>누적값%현재값, 6)
console.log(나머지) //결과 : 0
// 누적값 6고 1부터 순회하니 , 6 /1 의 나머지는 0이라 계속 0을 곱함.

//배열 : [1,2,3,4,5]

const 초기값미설정 = 배열.reduce((누적값,현재값)=>누적값%현재값)
console.log(초기값미설정)
// 1%2부터 시작하는데 몫이 0.5 , 나머지가 0이 되는 게 원래는 맞다.
// 그치만 자바스크립트 %연산자는 정수만 다루면,나머지도 정수로 뱉어낸다.
// 실수를 다루는 식이라면 그땐 나머지값도 실수로 뱉을 수 있다.
// 1.5 % 1.75 ~ : 실수나올 수 있음.
// 1 % 2 : 1을 뱉어요. 설계차이