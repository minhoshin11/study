# 배열의 깊은 복사와 얕은 복사

## 데이터 타입

1-2section.md - 참고
|자료형|설명|
|---|---|
|Number(숫자)|따옴표 없이 표기한 숫자|
|String(문자열)|작은따옴표(``)나 큰따옴표("")로 묶어서 표현|
|Boolean|true, false 이 두 가지 값만 표현|
|undefined|자료형을 지정하지 않았을 때의 유형, 변수를 선언만 한 경우|
|null|값이 유효하지 않을 때의 유형|
|Array(배열)|여러 값을 저장하는 자료형|
|Object(객체)|함수와 속성이 함께 포함된 자료형|

이 자료형의 데이터 타입은 크게 2가지로 나눌 수 있다.

#### 기본형(primitive type)
Number, String, Boolean, undefined, null 등

#### 참조형(reference type)
Array, Object 등

위와 같은 데이터 타입의 구분의 기준 중 하나는 불변성(immutability)이다.  
기본형은 불변성을 띈다. 즉 기본형은 변하지 않는다는 것이다.  
지금은 기본형이 불변성을 띈다는 말이 아직 이해되지는 않을 것이다.  
이 부분을 차근차근 설명해 보겠다.

<br />

## 메모리
앞선 수업에서 언급했던 것처럼 컴퓨터는 모든 데이터를 0과 1로 처리하고 저장한다. 그리고 0과 1을 저장하는 메모리 조각을 bit라고 한다.   
그리고 이것보다 큰 데이터의 단위가 1바이트이고 이는 8비트로 구성되어 있다. 

C나 C++, Java와 같은 정적 타입 언어는 메모리 낭비를 최소화하기 위해 데이터 타입별로 메모리의 크기를 정해놓았다.   
그래서 자바의 경우 정수를 담는 자료형만해도 4가지(byte, short, int, long)이고 각각 자료형에 담을 수 있는 정수의 크기가 정해져 있다.  
예를 short는 2bytes(16bit)이고 이는 -36,768 ~ 32,767까지의 정수를 표현 가능하고, int는 4bytes(32bit)로 -2,147,483,648 ~ 2,147,483,647 사이의 정수를 표현할 수 있다.  

하지만 컴퓨터의 발달로 인해 과거보다 메모리 용량이 늘어났고, 이후에 등장한 자바스크립트, 파이썬과 같은 언어는 메모리 관리에 자유로워졌다.  
그래서 자바스크립트의 숫자(Number)타입은 8byte(64bit)를 저장할 수 있다.

<br />

## 변수의 선언과 초기화
1-2section.md 참고

### 메모리

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|_|_|

<br>

### 1. 변수 선언

```javascript
let a;
```

a라는 변수를 선언한다.

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: a 값: undefined|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|_|_|

<br>

### 2. 변수 초기화

```javascript
a = 10;
```

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: a 값: @5004|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|10|_|

변수 a를 10으로 초기화

<br>

### 3. 값 재할당
```javascript
a = "Hi";
```

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: a 값: @5001|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|"Hi"|_|_|10|_|

## 기본형 데이터와 참조형 데이터

### 불변값

다만, 여기서 말하는 불변성의 여부는 상수의 개념과는 다르다.  
상수에서의 불변값은 변수 영역 메모리이다.  
반면 여기서 말하는 불변값은 데이터 영역 메모리이다. 

앞서 말했듯 기본형 데이터(Number, String, Boolean, null, undefined)은 불변값이다.

### 예제 1)
```javascript
let a = "hi ";
a = a + "im kim";
```
이 코드는 기존의 "hi "가 "hi im kim"으로 바뀌는게 아니다. 새로운 문자열 "hi im kim"이 만들어지고 이 문자열의 주소가 변수 a에 저장되는 것이다.

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: a 값: @5001|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|"hi"|_|_|_|_|

<hr>

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: a 값: @5003|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|"hi"|_|"hi im kim"|_|_|

### 예제 2)

```javascript
let b = 3;
let c = 3;
b = 9;
```

이 예제에서는 b에 숫자 3을 할당한다. 그러면 컴퓨터는 데이터 영역에서 3을 찾고, 없으면 데이터를 새로 생성한다. 그리고 생성된 주소를 b에 할당한다.  
c는 컴퓨터가 데이터 영역에서 3을 찾는 과정에 3이 존재하므로 그 주소를 c에 할당한다.  
그리고 b에 새로운 9의 값을 대입하면, 컴퓨터는 동일한 과정을 거친다. 9를 데이터 영역에서 찾고, 없으면 해당 데이터를 생성한 후 주소를 b에 연결하는 것이다.

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: b 값: |_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|3|_|

<hr>

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: b 값: @5004 |_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|3|_|

<hr>

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: b 값: @5004 |_|_|이름: c 값: |_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|3|_|

<hr>

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: b 값: @5004 |_|_|이름: c 값: @5004|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|_|_|3|_|

<hr>

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: b 값: @5001 |_|_|이름: c 값: @5004|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|9|_|_|3|_|

이처럼 기본형(Number, String ...)은 데이터를 수정할 수 없는 것이다. 즉 불변성을 띄는 것이다.

### 가변값
기본형은 모두 불변값이다.  
하지만 모든 참조형이 가변값인것은 아니다. 다만, 우선은 가변값에 초점을 두고 설명하겠다.

```javascript
let arr = [1, 2];
```

이 예시를 메모리로 나타내면 아래와 같다.

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: arr 값: @5001|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|@2001 ~ ?|_|1|2|_|

#### 배열 @5001의 변수 영역

|주소|...|2001|2002|2003|2004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: 0 값: @5003|이름: 1 값: @5004|_|_|_|

여기에서 재할당을 수행하면 아래와 같다.

```javascript
let arr = [1, 2];
arr[0] = 5;
```

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: arr 값: @5001|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|@2001 ~ ?|5|1|2|_|

#### 배열 @5001의 변수 영역

|주소|...|2001|2002|2003|2004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: 0 값: @5002|이름: 1 값: @5004|_|_|_|

위 표 처럼 2001의 값이 @5003에서 @5002로 변하는 것이다. 바로 이 부분 때문에 불변이 아니라 가변성의 성격을 띄는 것이다.

## 복사

### 기본형 데이터 복사

```javascript
let a = 1;
let b = a;
```

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: a 값: @5002|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|1|_|_|_|

<hr>

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: a 값: @5002|_|이름: b 값: @5002|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|_|1|_|_|_|


### 참조형 데이터 복사

```javascript
let arr1 = [1, 2];
let arr2 = arr1;
```

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: arr1 값: @5001|_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|@2001 ~ ?|_|1|2|_|

#### 배열 @5001의 변수 영역

|주소|...|2001|2002|2003|2004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: 0 값: @5003|이름: 1 값: @5004|_|_|_|

<hr>

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: arr1 값: @5001|_|이름: arr2 값: @5001|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|@2001 ~ ?|_|1|2|_|

#### 배열 @5001의 변수 영역

|주소|...|2001|2002|2003|2004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: 0 값: @5003|이름: 1 값: @5004|_|_|_|

이 상황에서 값을 재할당을 하면 아래와 같다.

```javascript
arr1[0] = 5;
```

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: arr1 값: @5001|_|이름: arr2 값: @5001|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|...|
|---|---|---|---|---|---|---|
|데이터|_|@2001 ~ ?|5|1|2|_|

#### 배열 @5001의 변수 영역

|주소|...|2001|2002|2003|2004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: 0 값: @5002|이름: 1 값: @5004|_|_|_|

여기에서 중요한 점은 배열 b도 값이 같이 변한다는 것이다!!!

```javascript
let arr1 = [1, 2];
let arr2 = arr1;

arr1[0] = 5;

console.log(arr1); // [5, 2]
console.log("------");
console.log(arr2); // [5, 2]
```

즉 이렇게 참조를 공유하면서 복사하는 방식을 얕은 복사(shallow copy)라고 한다.

## 깊은 복사(deep copy)
얕은 복사의 경우 값을 공유하는 문제가 있을 수 있으므로 깊은 복사를 사용한다.

### 반복문 사용
```javascript
let arr1 = [1, 2];
let arr2 = [];

for (let i = 0; i < arr1.length; i++) {
  arr2.push(arr1[i]);
}

console.log(arr2); // [1, 2]

arr1[0] = 5;

console.log(arr1); // [5, 2]
console.log(arr2); // [1, 2]
```
이렇게 아예 새로운 배열을 생성하는 방식이 있다.

#### 변수 영역

|주소|...|1001|1002|1003|1004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: arr1 값: @5001|_|이름: arr2 값: @5005|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003|5004|5005|
|---|---|---|---|---|---|---|
|데이터|_|@2001 ~ ?|5|1|2|@3001 ~ ?|

#### 배열 @5001의 변수 영역

|주소|...|2001|2002|2003|2004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: 0 값: @5002|이름: 1 값: @5004|_|_|_|

#### 배열 @5005의 변수 영역

|주소|...|3001|3002|3003|3004|...|
|---|---|---|---|---|---|---|
|데이터|_|이름: 0 값: @5003|이름: 1 값: @5004|_|_|_|

이 형태만을 깊은 복사라고 하지 않고, concat(), slice()를 사용하는 방식, JSON을 통한 방식 등등이 있는데 여기에서 중요한 것은 이거의 원리이다! 
