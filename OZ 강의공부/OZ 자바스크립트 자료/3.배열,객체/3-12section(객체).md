
# 객체

## 가변값인 객체
참조형 데이터인 객체의 가번값을 아래의 예시 코드를 통해 확인해보겠다.

```javascript
let obj1 = {
  a: 1,
  b: "hi"
};
```

#### 변수 영역

|주소|...| 1001              |1002|1003|1004|...|
|---|---|-------------------|---|---|---|---|
|데이터|_| 이름: obj1 값: @5001 |_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003| 5004 |...|
|---|---|---|---|---|------|---|
|데이터|_|@2001 ~ ?|_|1| "hi" |_|

#### 객체 @5001의 변수 영역

|주소|...| 2001           | 2002           |2003|2004|...|
|---|---|----------------|----------------|---|---|---|
|데이터|_| 이름: a 값: @5003 | 이름: b 값: @5004 |_|_|_|

이처럼 배열과 거의 유사한 형태로 데이터를 저장한다.  
이름이 배열과는 달리 객체의 key값임을 확인할 수 있다.

그래도 이를 다시 정리해보면,
1. 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정한다.
2. 데이터 역역(@5001)에 데이터를 저장하려니 여러 개의 데이터 그룹이므로 내부 데이터를 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@2001 ~ ?)를 @5001에 저장한다.
3. @2001, @2002 각각에 a와 b를 지정한다.
4. @2001은 데이터 영역에서 1을 검색한다. 검색 결과가 없으면 임의로 @5003에 저장하고 이 주소를 @2001에 저장한다.
5. @2002는 데이터 영역에서 "hi"를 검색한다. 검색 결과가 없으면 임의로 @5004에 저장하고 이 주소를 @2002에 저장한다.

### 객체의 재할당
객체의 재할당도 배열의 재할당과 매우 유사하다.

```javascript
let obj1 = {
  a: 1,
  b: "hi"
};

obj1.a = 5;
```

#### 변수 영역

|주소|...| 1001              |1002|1003|1004|...|
|---|---|-------------------|---|---|---|---|
|데이터|_| 이름: obj1 값: @5001 |_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003| 5004 |...|
|---|---|---|---|---|------|---|
|데이터|_|@2001 ~ ?|_|1| "hi" |_|

#### 객체 @5001의 변수 영역

|주소|...| 2001           | 2002           |2003|2004|...|
|---|---|----------------|----------------|---|---|---|
|데이터|_| 이름: a 값: @5003 | 이름: b 값: @5004 |_|_|_|

이렇게 obj1을 메모리에 생성한 이후  
`obj1.a = 5` 이렇게 재할당을 하면 아래와 같은 과정을 겪는다.

1. 데이터 영역에서 5를 검색한다.
2. 검색 결과가 없으면 빈 공간(@5002)에 5를 저장한다.
3. 그리고 이 주소(@5002)를 @2001에 저장한다.

#### 변수 영역

|주소|...| 1001              |1002|1003|1004|...|
|---|---|-------------------|---|---|---|---|
|데이터|_| 이름: obj1 값: @5001 |_|_|_|_|

#### 데이터 영역

|주소|...|5001| 5002 |5003| 5004 |...|
|---|---|---|------|---|------|---|
|데이터|_|@2001 ~ ?| 5    |1| "hi" |_|

#### 객체 @5001의 변수 영역

|주소|...| 2001           | 2002           |2003|2004|...|
|---|---|----------------|----------------|---|---|---|
|데이터|_| 이름: a 값: @5002 | 이름: b 값: @5004 |_|_|_|

이처럼 `obj1`이 바라보고 있는 주소 @5001은 변하지 않는다. 기존 객체 내부의 값이 바뀐 것이다.  

### 객체 안의 배열

객체는 다양한 자료형이 저장된다. 물론 배열도 저장될 수 있다.

```javascript
let obj1 = {
  a: 1,
  arr: [1, 2, 3]
};
```

1. 컴퓨터는 변수 영역의 빈 공간(@1001)을 확보하고, 이 주소의 이름을 obj1로 지정한다.
2. 데이터 영역에 이 데이터를 저장하려는데, 이 데이터는 객체이므로 객체의 각 값들을 저장하기 위해 별도의 변수 영역(@2001 ~ ?)을 마련한다. 이 영역의 주소를 @5001에 저장한다. 
3. @2001 이름에 a를 지정하고, @2002 이름에 arr을 지정한다.
4. 데이터 영역에서 1을 검색하고 없으면 @5002에 해당 값을 저장하고 이 주소를 @2001에 저장한다.
5. @2002에 저장할 값인 배열(arr)은 데이터 그룹이므로 내부 값들을 저장하기 위해 별도의 변수 영역(배열 @2002의 변수 영역)을 마련한다.
6. 이 영역의 주소 정보(@4001 ~ ?)를 @2002에 저장한다.
7. 배열의 요소가 총 3개이므로 3개의 변수 공간(@4001 ~ @4003)을 확보하고 각각의 인덱스(0, 1, 2)를 부여한다.
8. 데이터 영역에서 1을 검색하고 1이 있으므로 1이 저장된 @5002을 @4001에 저장한다.
9. 데이터 영역에서 2를 검색하고 없으므로 @5003에 2를 저장하고 이 주소를 @4002에 저장한다.
10. 데이터 영역에서 3를 검색하고 없으므로 @5004에 3를 저장하고 이 주소를 @4003에 저장한다.

#### 변수 영역

|주소|...| 1001              |1002|1003|1004|...|
|---|---|-------------------|---|---|---|---|
|데이터|_| 이름: obj1 값: @5001 |_|_|_|_|

#### 데이터 영역

|주소|...|5001| 5002 | 5003 | 5004 |...|
|---|---|---|------|------|------|---|
|데이터|_|@2001 ~ ?| 1    | 2    | 3    |_|

#### 객체 @5001의 변수 영역

|주소|...| 2001           | 2002                 |2003|2004|...|
|---|---|----------------|----------------------|---|---|---|
|데이터|_| 이름: a 값: @5002 | 이름: arr 값: @4001 ~ ? |_|_|_|

#### 배열 @2002의 변수 영역

|주소|...| 4001           | 4002           | 4003           | 4004 |...|
|---|---|----------------|----------------|----------------|------|---|
|데이터|_| 이름: 0 값: @5002 | 이름: 1 값: @5003 | 이름: 2 값: @5004 | _    |_|

### 객체의 얕은 복사

객체에서도 배열과 마찬가지로 얕은 복사, 깊은 복사 개념이 동일하게 존재하며 과정 또한 매우 유사하다.

```javascript
let obj1 = { a: 1, b: "hi" };
let obj2 = obj1;
```

#### 변수 영역

|주소|...| 1001              |1002|1003|1004|...|
|---|---|-------------------|---|---|---|---|
|데이터|_| 이름: obj1 값: @5001 |_|_|_|_|

#### 데이터 영역

|주소|...|5001|5002|5003| 5004 |...|
|---|---|---|---|---|------|---|
|데이터|_|@2001 ~ ?|_|1| "hi" |_|

#### 객체 @5001의 변수 영역

|주소|...| 2001           | 2002           |2003|2004|...|
|---|---|----------------|----------------|---|---|---|
|데이터|_| 이름: a 값: @5003 | 이름: b 값: @5004 |_|_|_|

위에 표는 `let obj1 = { a: 1, b: "hi" };` 상태이다.  
여기에서 `let obj2 = obj1;`이 실행되면 아래와 같아진다.

#### 변수 영역

|주소|...| 1001              |1002| 1003              |1004|...|
|---|---|-------------------|---|-------------------|---|---|
|데이터|_| 이름: obj1 값: @5001 |_| 이름: obj2 값: @5002 |_|_|

#### 데이터 영역

|주소|...|5001| 5002      |5003| 5004 |...|
|---|---|---|-----------|---|------|---|
|데이터|_|@2001 ~ ?| @2001 ~ ? |1| "hi" |_|

#### 객체 @5001의 변수 영역

|주소|...| 2001           | 2002           |2003|2004|...|
|---|---|----------------|----------------|---|---|---|
|데이터|_| 이름: a 값: @5003 | 이름: b 값: @5004 |_|_|_|

변수 영역의 빈 공간(@1003)에 식별자를 obj2로 지정한다. 이후 식별자 obj1을 검색해 그 값인 @5001을 @1003의 값으로 대입하게 된다.  
그래서 객체의 경우에도 얕은 복사를 수행하면 두 객체(obj1, obj2) 모두 같은 값을 바라보게 된다.

이 상태에서 obj2 객체의 값을 변경하면 아래와 같은 변화가 생긴다.
```javascript
obj2.a = 5;
```

#### 변수 영역

|주소|...| 1001              |1002| 1003              |1004|...|
|---|---|-------------------|---|-------------------|---|---|
|데이터|_| 이름: obj1 값: @5001 |_| 이름: obj2 값: @5002 |_|_|

#### 데이터 영역

|주소|...|5001| 5002      |5003| 5004 | 5005 |
|---|---|---|-----------|---|------|------|
|데이터|_|@2001 ~ ?| @2001 ~ ? |1| "hi" | 5    |

#### 객체 @5001의 변수 영역

|주소|...| 2001           | 2002           |2003|2004|...|
|---|---|----------------|----------------|---|---|---|
|데이터|_| 이름: a 값: @5005 | 이름: b 값: @5004 |_|_|_|

데이터 영역에서 5를 찾고 없으므로 새로운 공간인 @5005에 5를 저장한다. 그리고 @2001의 값을 @5005로 변경하게 된다.  
그래서 같은 @2001을 바라보고 있는 obj1, obj2 모두의 a가 1에서 5로 변경되는 것이다.

### 객체의 깊은 복사

객체의 깊은 복사에도 다양한 방식이 있으나, 이번에는 JSON을 활용한 방식을 보겠다.

참고) JSON  
JSON(JavaScript Object Notation)은 이름에서도 알 수 있듯이 JavaScript 객체(Object) 표기법(Notation) 정도로 볼 수 있다.  
그래서 JavaScript 객체와 매우 유사하다. 하지만 여러가지 이유 때문에 자바스크립트 문법 개념인 객체 자체는 아니고 객체를 문자열로 변환했다고 보면 된다.

```javascript
let obj1 = {
  a: 1,
  b: {
    c: 2,
    d: "hi",
  }
}

let obj2 = JSON.parse(JSON.stringify(obj1));
```
이 두가지 JSON함수를 사용하면 된다.  
위에서 사용된 JSON 함수를 간단히 설명하면,  
`JSON.stringify()`은 JavaScript의 객체를 JSON 형식으로 변환하는 것이고,  
`JSON.parse()`는 JSON을 JavaScript객체로 변환하는 문법이다.  
이 과정을 거치면, 컴퓨터는 새로운 객체로 인식하기 때문에 새로운 메모리에 obj2를 저장한다. 그래서 이를 활용해 깊은 복사를 진행할 수 있다.  
참고로 배열도 JSON 함수를 사용해서 깊은 복사를 할 수 있다.




